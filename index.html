<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pothole Detections Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    :root{ --pad:14px; --header-h:64px; --border:#d7d7d7; --bg:#f6f7f9; }
    html, body { height: 100%; margin: 0; background: var(--bg); font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .topbar{ position: sticky; top:0; z-index:1000; height:var(--header-h); display:flex; align-items:center; gap:10px; flex-wrap:wrap; padding:8px var(--pad); background:#fff; box-shadow:0 1px 8px rgba(0,0,0,.08); }
    .topbar .spacer{ flex:1 }
    .panel{ height: calc(100vh - var(--header-h) - var(--pad)*2); padding: var(--pad); }
    .map-wrap{ height:100%; border:2px solid var(--border); border-radius:12px; overflow:hidden; background:#fff; }
    #map{ height:100%; width:100%; }
    button, select, label { font-size:14px; }
    .thumb { max-width:420px; width:100%; height:auto; display:block; border-radius:10px; }
    .meta { margin-top:8px; font-size:14px; color:#222; line-height:1.35; }
    .meta b { font-weight:700; }
    .legend { background:#fff; padding:8px 10px; border-radius:8px; box-shadow:0 1px 6px rgba(0,0,0,.15); font-size:12px; }
    .legend .row { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .legend .sw { width:14px; height:14px; border-radius:50%; border:1px solid #3333; }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="reset">Reset view</button>
    <button id="refresh">Refresh</button>
    <label><input type="checkbox" id="showUnfixed" checked> Unfixed</label>
    <label><input type="checkbox" id="showFixed" checked> Fixed</label>
    <div class="spacer"></div>
    <label>Auto-refresh
      <select id="interval">
        <option value="10000" selected>10s</option>
        <option value="30000">30s</option>
        <option value="60000">60s</option>
        <option value="0">Off</option>
      </select>
    </label>
  </div>

  <div class="panel">
    <div class="map-wrap"><div id="map"></div></div>
  </div>

  <script>
    // ----------- CONFIG ----------- 
    const PX2CM = 0.40;                 // pixel -> centimetre scale
    const DEFAULT_WEATHER_DESC = "Clear";
    const DEFAULT_TEMP_C = null;        
    const IMAGE_ROOT = "./";            // images are in the same folder

    // ----------- Helpers -----------
    function colorForDiameter(cm){
      if (cm >= 60) return "#e53935";
      if (cm >= 30) return "#fb8c00";
      return "#43a047";
    }
    function diameterFromAreaPx(areaPx, px2cm=PX2CM){
      if (!areaPx || areaPx<=0) return null;
      const d_px = 2*Math.sqrt(areaPx/Math.PI);
      return +(d_px*px2cm).toFixed(1);
    }

    // Parse *_YYYYMMDD-HHMMSS(-ms)_ from filename
    const TS_RE = /_(\d{8})-(\d{6})(?:-(\d{3}))?_/;
    function timeFromFilename(name){
      const m = TS_RE.exec(name || "");
      if (!m) return "";
      const ymd=m[1],hms=m[2],ms=m[3]||"000";
      const iso = `${ymd.slice(0,4)}-${ymd.slice(4,6)}-${ymd.slice(6,8)}T${hms.slice(0,2)}:${hms.slice(2,4)}:${hms.slice(4,6)}.${ms}`;
      const d = new Date(iso);
      if (isNaN(d.getTime())) return "";
      return d.toLocaleString();
    }

    // Build an <img> with fallbacks so thumbnails always try sane paths
    function thumbHTML(p){
      const file = (p.image || "").split("/").pop();
      let candidates = [];
      if (p.image_url) {
        let u = p.image_url.replace("./detections/","./").replace("detections/","./");
        candidates.push(u);
      }
      if (file) { candidates.push(IMAGE_ROOT + file); candidates.push(file); }
      if (candidates.length === 0) return "";

      const first = encodeURI(candidates[0]);
      const rest  = candidates.slice(1).map(encodeURI);
      const handler = `
        (function(img){
          if(!img._alts){ img._alts=${JSON.stringify(rest)}; img._i=0; }
          if(img._i < img._alts.length){ img.src = img._alts[img._i++]; }
          else { img.style.display='none'; }
        })(this)
      `.replace(/\s+/g,' ');
      return `<img class="thumb" src="${first}" alt="annotated" onerror="${handler}">`;
    }

    // Weather formatter -> "18°C Clear"
    function formatWeather(p){
      // Candidate description fields
      const descRaw = p.weather_desc ?? p.wx_desc ?? p.conditions ?? p.condition ?? p.wx ?? null;

      // Candidate temperature (°C) fields
      let temp = p.temp_c ?? p.temperature_c ?? null;

      // If `weather` is a bare number string like "18", use as temp
      if (temp == null && p.weather != null) {
        const w = String(p.weather).trim();
        const n = Number(w);
        if (!Number.isNaN(n)) temp = n;
      }

      // If `weather` already looks like descriptive text, keep it and normalize units.
      if (temp == null && typeof p.weather === "string" && /[a-zA-Z]/.test(p.weather)) {
        return p.weather
          .replace(/(\d)\s*c\b/i, '$1°C')
          .replace(/\s+deg(ree)?s?\s*C?/i, '°C')
          .replace(/\s+/g,' ')
          .trim();
      }

      const t = (temp != null) ? `${Number(temp).toFixed(0)}°C` : (DEFAULT_TEMP_C!=null ? `${DEFAULT_TEMP_C}°C` : null);
      const d = descRaw ? (String(descRaw).charAt(0).toUpperCase()+String(descRaw).slice(1)) : DEFAULT_WEATHER_DESC;

      return t ? `${t} ${d}` : d; // EXACT format: "18°C Clear"
    }

    function popupHTML(p){
      const diameter = (p.diameter_cm != null) ? p.diameter_cm : diameterFromAreaPx(Number(p.area_px)||0);
      const when     = p.time || p.timestamp || timeFromFilename(p.image || "");

      const lines = [];
      if (p.image)  lines.push(`<div><b>${p.image}</b></div>`);
      if (diameter) lines.push(`<div><b>Diameter:</b> ${diameter} cm</div>`);
      lines.push(`<div><b>Weather:</b> ${formatWeather(p)}</div>`);
      lines.push(`<div><b>Time:</b> ${when || "—"}</div>`);
      if (p.conf!=null) lines.push(`<div><b>Conf:</b> ${Number(p.conf).toFixed(2)}</div>`);
      if (p.lat && p.lon) lines.push(`<div><b>Coords:</b> ${Number(p.lat).toFixed(5)}, ${Number(p.lon).toFixed(5)}</div>`);
      if (p.alt!=null)    lines.push(`<div><b>Alt:</b> ${p.alt} m</div>`);
      if (p.spd!=null)    lines.push(`<div><b>Speed:</b> ${p.spd} km/h</div>`);

      return thumbHTML(p) + `<div class="meta">${lines.join('')}</div>`;
    }

    function circleMarkerForFeature(f, latlng){
      const p = f.properties || {};
      const dcm = (p.diameter_cm != null) ? Number(p.diameter_cm)
                                          : diameterFromAreaPx(Number(p.area_px)||0);
      const col = colorForDiameter(dcm || 0);
      return L.circleMarker(latlng, { radius:8, weight:2, color:col, fillColor:col, fillOpacity:0.85, title:(p.status||'unfixed') });
    }

    // ----------- Map setup -----------
    const map = L.map('map', { minZoom:3, maxZoom:19, zoomControl:true });
    L.control.scale({ metric:true, imperial:false }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(map);
    map.setView([0,0], 2);

    const clusterUnfixed = L.markerClusterGroup({ showCoverageOnHover:false });
    const clusterFixed   = L.markerClusterGroup({ showCoverageOnHover:false });
    clusterUnfixed.addTo(map); clusterFixed.addTo(map);

    let lastBounds=null, lastCenter=null;

    async function loadData(){
      const res = await fetch('detections.geojson?v=' + Date.now());
      if(!res.ok) throw new Error('Failed to load detections.geojson');
      const geo = await res.json();

      clusterUnfixed.clearLayers(); clusterFixed.clearLayers();
      let count = 0;

      L.geoJSON(geo, {
        pointToLayer: (f, latlng) => circleMarkerForFeature(f, latlng),
        onEachFeature: (f, layer) => {
          count++;
          const p = f.properties || {};

          // If missing explicit time fields, try filename timestamp.
          if (!p.time && !p.timestamp && p.image) {
            const t = timeFromFilename(p.image);
            if (t) p.time = t;
          }
          // If missing diameter, derive from area_px.
          if (p.diameter_cm == null && p.area_px != null) {
            p.diameter_cm = diameterFromAreaPx(Number(p.area_px)||0);
          }

          layer.bindPopup(popupHTML(p), { maxWidth: 460 });

          const status = (p.status || 'unfixed').toLowerCase();
          if (status === 'fixed') clusterFixed.addLayer(layer); else clusterUnfixed.addLayer(layer);
        }
      });

      const b1 = clusterUnfixed.getBounds(), b2 = clusterFixed.getBounds();
      const bounds = (b1.isValid() && b2.isValid()) ? b1.extend(b2) : (b1.isValid()?b1:(b2.isValid()?b2:null));
      lastBounds = bounds;
      const MAX_FIT_ZOOM=16, MIN_FIT_ZOOM=6;
      if (bounds && bounds.isValid()){
        map.fitBounds(bounds.pad(0.15));
        const z = map.getZoom(), clamp = Math.max(MIN_FIT_ZOOM, Math.min(z, MAX_FIT_ZOOM));
        if (clamp !== z) map.setZoom(clamp);
        lastCenter = map.getCenter();
      } else { map.setView([0,0],2); lastCenter = map.getCenter(); }
      if (count===1){ map.setZoom(15); lastCenter = map.getCenter(); }
    }

    // Legend
    const legend = L.control({position:'bottomleft'});
    legend.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><b>Diameter (cm)</b></div>
        <div class="row"><span class="sw" style="background:#43a047"></span> &lt; 30</div>
        <div class="row"><span class="sw" style="background:#fb8c00"></span> 30–60</div>
        <div class="row"><span class="sw" style="background:#e53935"></span> &gt; 60</div>`;
      return div;
    };
    legend.addTo(map);

    // UI
    document.getElementById('refresh').addEventListener('click', loadData);
    document.getElementById('reset').addEventListener('click', () => {
      if (lastBounds && lastBounds.isValid()){
        map.fitBounds(lastBounds.pad(0.15));
        const z=map.getZoom(), clamp=Math.max(6, Math.min(z,16));
        if (clamp !== z) map.setZoom(clamp);
      } else if (lastCenter) { map.setView(lastCenter, 12); }
      else { map.setView([0,0],2); }
    });
    document.getElementById('showUnfixed').addEventListener('change', e => {
      if (e.target.checked) map.addLayer(clusterUnfixed); else map.removeLayer(clusterUnfixed);
    });
    document.getElementById('showFixed').addEventListener('change', e => {
      if (e.target.checked) map.addLayer(clusterFixed); else map.removeLayer(clusterFixed);
    });

    // Auto-refresh
    let timer = setInterval(loadData, 10000);
    document.getElementById('interval').addEventListener('change', e => {
      const ms = Number(e.target.value);
      if (timer) { clearInterval(timer); timer=null; }
      if (ms>0) timer=setInterval(loadData, ms);
      loadData();
    });

    // Initial load
    loadData().catch(err => {
      console.error(err);
      alert('Could not load detections.geojson. Make sure it is next to map.html and contains features.');
    });
  </script>
</body>
</html>



