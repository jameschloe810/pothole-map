<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pothole Detections Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    :root{ --pad:14px; --header-h:64px; --border:#d7d7d7; --bg:#f6f7f9; }
    html, body { height: 100%; margin: 0; background: var(--bg); font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .topbar{ position: sticky; top:0; z-index:1000; height:var(--header-h); display:flex; align-items:center; gap:10px; flex-wrap:wrap; padding:8px var(--pad); background:#fff; box-shadow:0 1px 8px rgba(0,0,0,.08); }
    .topbar .spacer{ flex:1 }
    .panel{ height: calc(100vh - var(--header-h) - var(--pad)*2); padding: var(--pad); }
    .map-wrap{ height:100%; border:2px solid var(--border); border-radius:12px; overflow:hidden; background:#fff; }
    #map{ height:100%; width:100%; }
    button, select, label { font-size:14px; }
    .thumb { max-width:360px; width:100%; height:auto; display:block; border-radius:6px; }
    .meta { margin-top:6px; font-size:12px; color:#333; }
    .meta b { font-weight:600; }
    .legend { background:#fff; padding:8px 10px; border-radius:8px; box-shadow:0 1px 6px rgba(0,0,0,.15); font-size:12px; }
    .legend .row { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .legend .sw { width:14px; height:14px; border-radius:50%; border:1px solid #3333; }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="reset">Reset view</button>
    <button id="refresh">Refresh</button>
    <label><input type="checkbox" id="showUnfixed" checked> Unfixed</label>
    <label><input type="checkbox" id="showFixed" checked> Fixed</label>
    <div class="spacer"></div>
    <label>Auto-refresh
      <select id="interval">
        <option value="10000" selected>10s</option>
        <option value="30000">30s</option>
        <option value="60000">60s</option>
        <option value="0">Off</option>
      </select>
    </label>
  </div>

  <div class="panel">
    <div class="map-wrap"><div id="map"></div></div>
  </div>

  <script>
    // ===== CONFIG =====
    const PX2CM = 0.35;
    const DEFAULT_WEATHER = "Clear";
    // Keep images in the SAME folder as index.html by default:
    const IMAGE_ROOT = "./";

    // ===== TIME HELPERS =====
    // More permissive pattern: accepts separators and no trailing underscore.
    const FLEX_TS_RE = /(?:^|[_\/-])(\d{8})[-_]?(\d{6})(?:[-_](\d{3}))?(?:[_\.]|$)/;

    function parseAnyTime(val){
      if (!val) return null;

      // If number-like → epoch (ms or s)
      if (/^\d{10,13}$/.test(String(val))) {
        const n = Number(val);
        const ms = (String(val).length === 13) ? n : n*1000;
        const d = new Date(ms);
        return isNaN(d.getTime()) ? null : d;
      }

      // ISO or ISO-ish
      if (typeof val === 'string') {
        // Try native
        let d = new Date(val);
        if (!isNaN(d.getTime())) return d;

        // If looks like "YYYY-MM-DDTHH:mm:ss.sss" but browser is fussy, add Z (UTC)
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?$/.test(val)) {
          d = new Date(val + 'Z');
          if (!isNaN(d.getTime())) return d;
        }

        // Try compact filename pattern: 20251015-171000(-388)
        const m = FLEX_TS_RE.exec(val);
        if (m) {
          const y = m[1].slice(0,4), M = m[1].slice(4,6), D = m[1].slice(6,8);
          const hh = m[2].slice(0,2), mm = m[2].slice(2,4), ss = m[2].slice(4,6);
          const ms = m[3] ? m[3].padEnd(3,'0') : '000';
          // Build an ISO-UTC string to avoid locale quirks
          const isoUTC = `${y}-${M}-${D}T${hh}:${mm}:${ss}.${ms}Z`;
          d = new Date(isoUTC);
          if (!isNaN(d.getTime())) return d;
        }
      }

      return null;
    }

    function timeFromProps(p){
      // Priority: explicit fields if present
      const candidates = [p.time, p.timestamp, p.date, p.datetime, p.image, p.image_url];
      for (const c of candidates) {
        const d = parseAnyTime(c);
        if (d) return d;
      }
      return null;
    }

    function humanTimeFromProps(p){
      const d = timeFromProps(p);
      return d ? d.toLocaleString() : '—';
    }

    // ===== IMAGE HELPER =====
    function thumbHTML(p){
      const file = (p.image || "").split("/").pop();
      const candidates = [];

      if (p.image_url) {
        // Normalise obvious path fragments
        let u = p.image_url.replace("./detections/","./")
                           .replace("detections/","./")
                           .replace("./images/","./");
        candidates.push(u);
      }
      if (file) {
        candidates.push(IMAGE_ROOT + file);      // ./filename.jpg
        candidates.push('images/' + file);       // images/filename.jpg
        candidates.push('detections/' + file);   // detections/filename.jpg
      }
      if (!candidates.length) return "";

      const first = encodeURI(candidates[0]);
      const rest  = candidates.slice(1).map(encodeURI);
      const onerr = `
        (function(img){
          if(!img._alts){ img._alts=${JSON.stringify(rest)}; img._i=0; }
          if(img._i < img._alts.length){ img.src = img._alts[img._i++]; }
          else { img.style.display='none'; }
        })(this)
      `.replace(/\s+/g,' ');

      return `<img class="thumb" src="${first}" alt="annotated" onerror="${onerr}">`;
    }

    function diameterFromAreaPx(areaPx, px2cm=PX2CM){
      if (!areaPx || areaPx<=0) return null;
      const d_px = 2*Math.sqrt(areaPx/Math.PI);
      return +(d_px*px2cm).toFixed(1);
    }
    function colorForDiameter(cm){
      if (cm >= 60) return "#e53935";
      if (cm >= 30) return "#fb8c00";
      return "#43a047";
    }

    function popupHTML(p){
      const weather = (p.weather ?? p.wx ?? DEFAULT_WEATHER);
      const diameter = (p.diameter_cm != null) ? p.diameter_cm
                                               : diameterFromAreaPx(Number(p.area_px)||0);
      const when = humanTimeFromProps(p);

      const lines = [];
      if (p.image)  lines.push(`<div><b>${p.image}</b></div>`);
      if (diameter) lines.push(`<div><b>Diameter:</b> ${diameter} cm</div>`);
      lines.push(`<div><b>Weather:</b> ${weather}</div>`);
      lines.push(`<div><b>Time:</b> ${when}</div>`);
      if (p.conf!=null) lines.push(`<div>Conf: ${Number(p.conf).toFixed(2)}</div>`);
      if (p.lat && p.lon) lines.push(`<div>Coords: ${Number(p.lat).toFixed(5)}, ${Number(p.lon).toFixed(5)}</div>`);
      if (p.alt!=null)    lines.push(`<div>Alt: ${p.alt} m</div>`);
      if (p.spd!=null)    lines.push(`<div>Speed: ${p.spd} km/h</div>`);

      return thumbHTML(p) + `<div class="meta">${lines.join('')}</div>`;
    }

    function circleMarkerForFeature(f, latlng){
      const p = f.properties || {};
      const dcm = (p.diameter_cm != null) ? Number(p.diameter_cm)
                                          : diameterFromAreaPx(Number(p.area_px)||0);
      const col = colorForDiameter(dcm || 0);
      return L.circleMarker(latlng, { radius:8, weight:2, color:col, fillColor:col, fillOpacity:0.85, title:(p.status||'unfixed') });
    }

    // ===== MAP =====
    const map = L.map('map', { minZoom:3, maxZoom:19, zoomControl:true });
    L.control.scale({ metric:true, imperial:false }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(map);
    map.setView([0,0], 2);

    const clusterUnfixed = L.markerClusterGroup({ showCoverageOnHover:false });
    const clusterFixed   = L.markerClusterGroup({ showCoverageOnHover:false });
    clusterUnfixed.addTo(map); clusterFixed.addTo(map);

    let lastBounds=null, lastCenter=null;

    async function loadData(){
      const res = await fetch('detections.geojson?v=' + Date.now());
      if(!res.ok) throw new Error('Failed to load detections.geojson');
      const geo = await res.json();

      clusterUnfixed.clearLayers(); clusterFixed.clearLayers();
      let count = 0;

      L.geoJSON(geo, {
        pointToLayer: (f, latlng) => circleMarkerForFeature(f, latlng),
        onEachFeature: (f, layer) => {
          count++;
          const p = f.properties || {};
          if (!p.weather && p.wx) p.weather = p.wx;

          // Backfill diameter from area if needed
          if (p.diameter_cm == null && p.area_px != null) {
            p.diameter_cm = diameterFromAreaPx(Number(p.area_px)||0);
          }

          layer.bindPopup(popupHTML(p), { maxWidth: 420 });

          const status = (p.status || 'unfixed').toLowerCase();
          if (status === 'fixed') clusterFixed.addLayer(layer); else clusterUnfixed.addLayer(layer);
        }
      });

      const b1 = clusterUnfixed.getBounds(), b2 = clusterFixed.getBounds();
      const bounds = (b1.isValid() && b2.isValid()) ? b1.extend(b2) : (b1.isValid()?b1:(b2.isValid()?b2:null));
      lastBounds = bounds;
      const MAX_FIT_ZOOM=16, MIN_FIT_ZOOM=6;
      if (bounds && bounds.isValid()){
        map.fitBounds(bounds.pad(0.15));
        const z = map.getZoom(), clamp = Math.max(MIN_FIT_ZOOM, Math.min(z, MAX_FIT_ZOOM));
        if (clamp !== z) map.setZoom(clamp);
        lastCenter = map.getCenter();
      } else { map.setView([0,0],2); lastCenter = map.getCenter(); }
      if (count===1){ map.setZoom(15); lastCenter = map.getCenter(); }
    }

    // Legend
    const legend = L.control({position:'bottomleft'});
    legend.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.innerHTML = `
        <div><b>Diameter (cm)</b></div>
        <div class="row"><span class="sw" style="background:#43a047"></span> &lt; 30</div>
        <div class="row"><span class="sw" style="background:#fb8c00"></span> 30–60</div>
        <div class="row"><span class="sw" style="background:#e53935"></span> &gt; 60</div>`;
      return div;
    };
    legend.addTo(map);

    // UI
    document.getElementById('refresh').addEventListener('click', loadData);
    document.getElementById('reset').addEventListener('click', () => {
      if (lastBounds && lastBounds.isValid()){
        map.fitBounds(lastBounds.pad(0.15));
        const z=map.getZoom(), clamp=Math.max(6, Math.min(z,16));
        if (clamp !== z) map.setZoom(clamp);
      } else if (lastCenter) { map.setView(lastCenter, 12); }
      else { map.setView([0,0],2); }
    });
    document.getElementById('showUnfixed').addEventListener('change', e => {
      if (e.target.checked) map.addLayer(clusterUnfixed); else map.removeLayer(clusterUnfixed);
    });
    document.getElementById('showFixed').addEventListener('change', e => {
      if (e.target.checked) map.addLayer(clusterFixed); else map.removeLayer(clusterFixed);
    });

    // Auto-refresh
    let timer = setInterval(loadData, 10000);
    document.getElementById('interval').addEventListener('change', e => {
      const ms = Number(e.target.value);
      if (timer) { clearInterval(timer); timer=null; }
      if (ms>0) timer=setInterval(loadData, ms);
      loadData();
    });

    // Initial load
    loadData().catch(err => {
      console.error(err);
      alert('Could not load detections.geojson. Make sure it is next to index.html and contains valid GeoJSON point features.');
    });
  </script>
</body>
</html>

